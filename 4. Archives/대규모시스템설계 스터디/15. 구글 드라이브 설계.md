## 1단계. 문제 이해 및 설계 범위 확정

### 기능적 설계
-  주요 기능 - 파일 업로드/다운로드, 파일 동기화, 알림
- 모바일, 웹 지원
- 파일 암호화
- 파일 크기 10GB 제한
- 일간 능동 사용자 천만명
### 비기능적 설계
- 안정성 - 데이터 손실 X
- 빠른 동기화 속도
- 네트워크 대역폭
- 규모 확장성
- 높은 가용성
## 2단계. 개략적 설계안 제시 및 동의 구하기
### API
#### 업로드 API
  1. 단순 업로드 - 파일 크기가 작을 때 사용
  2. 이어 올리기 - 파일 크키가 크고, 네트워크 문제로 업로드가 중단될 가능성이 높을 때 사용
#### 다운로드 API
예 : https://api.example.com/files/download
#### 파일 갱신 히스토리 API
예 : https://api.example.com/files/list_revisions

모든 API는 데이터 보호를 위해 HTTPS 프로토콜을 사용해야한다
### 한 대 서버의 제약 극복
- 기존 서버 샤딩

- 로드 밸런서, 웹 서버
- 메타 데이터 DB, 파일 저장소(S3) 로 분리
### 동기화 충돌
먼저 처리되는 변경은 성공, 나중에 처리되는 변경은 충돌 발생
충돌 해소 전략은 다양
- 로컬 버전, 서버의 최신 버전을 합칠지, 다른 파일로 대체할지
## 3단계. 상세 설계
### 블록 저장소 서버
정기적으로 갱신되는 큰 파일들은 네트워크 대역폭을 많이 잡아먹게 됨
- 파일을 블록 단위로 나누고
- 델타 동기화 - 수정이 일어난 블록만 동기화
- 압축
- 암호화한 뒤 클라우드 저장소로 보낸다
### 높은 일관성 요구사항
- 메모리 캐시의 사본과 DB 원본이 일치해야 한다
- 원본에 변경이 발생하면 캐시에 있는 사본을 무효화한다
### 메타데이터 DB
user, device, namespace, file, file_version, block 보관
### 업로드 절차
- 1. 파일 메타 데이터 추가
  1. 클라이언트 1이 새 파일의 메타데이터를 추가하기 위해 요청
  2. 새 파일 메타데이터를 DB에 저장, 업로드 상태를 pending으로
  3. 새 파일 추가 알림 서비스에 통지
  4. 알림 서비스는 클라이언트 2에게 파일 업로드 알림
- 2. 파일을 클라우드 저장소에 업로드
  1. 클라이언트 1이 파일을 블록 저장소 서버에 업로드
  2. 블록 저장소 서버는 클라우드 저장소에 전송
  3. 업로드가 끝나면 클라우드 스토리지는 완료 콜백 호출
  4. 메타 데이터 DB 상태 uploaded로 
  5. 알림 서비스에 파일 업로드가 끝났음 통지
  6. 알림 서비스는 클라이언트에 파일 업로드 끝났음 알림
### 다운로드 절차
1. 알림 서비스가 클라이언트 2에게 파일 변경 알림
2. 알림 확인한 클라이언트 2는 새 메타데이터 요청
3. API 서버는 메타데이터 DB에 새 메타데이터 요청
4. API 서버에게 새 메타데이터 반환
5. 클라이언트 2에게 새 메타데이터 반환
6. 클라이언트 2는 새 메타데이터를 받는 즉시 블록 다운로드 요청 전송
7. 블록 저장소 서버는 클라우드 저장소에서 블록 다운
8. 클라우드 저장소는 블록 서버에 요청된 블록 반환
9. 블록 저장소 서버는 클라이언트에게 요청된 블록 반환, 클라이언트 2는 파일 재구성
### 알림 서비스
1. 롱 폴링
2. 웹 소켓 - 지속적인 통신 채널 제공, 양방향 통신

하지만, 드라이브 서비스에서는 채팅 서비스처럼 실시간 양방향 통신이 요구되지 않는다
### 저장소 공간 절약
모든 버전을 자주 백업하면 저장용량이 너무 빨리 소진됨
- 중복 제거 - 계정 차원에서 중복 블록 제거
- 지능적 백업 전략
  보관 파일 갯수 한도 설정, 중요한 버전만 보관
- 자주 쓰이지 않는 데이터는 아카이빙 저장소(S3 glacier)로 이동
### 장애 처리
로드 밸런서, 웹 서버, 캐시 서버, DB 등에서 발생하는 장애 -> 다중화
