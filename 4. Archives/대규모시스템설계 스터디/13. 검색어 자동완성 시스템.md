## 개략적 설계
### 데이터 수집 서비스
질의문과 사용 빈도를 저장하는 빈도 테이블
### 질의 서비스
query, frequency를 필드로 SQL 질의문으로 계산할 수 있다 -> 데이터가 많아지면 병목
```sql
select * from table
where query like 'prefix%'
order by frequency desc limit 5
```
## 상세 설계
### 트라이 자료구조
- 문자열을 간략하게 저장할 수 있는 자료구조 -> 문자열 꺼내기 연산에 최적화
t - tr - tru - true
		- try
- 트리 형태로 각 노드는 글자 하나를 저장
- 노드에 빈도 정보까지 저장
=> 최악의 경우, 전체 트라이를 다 검색해야하는 일이 발생
#### 성능 개선안
1. 접두어의 최대 길이 제한 -> O(p)에서 O(1)로 제한
2. 각 노드에 인기 검색어 캐시 -> 최고 인기 검색어 찾기 O(ClogC)에서 O(1)
=> O(p) + O(C) + O(ClogC)에서 O(1) + O(1)로 개선
### 데이터 수집 서비스
검색 서비스의 트라이는 SNS와 달리 즉시 갱신될 필요가 없다 -> 데이터 수집 서비스 설계 개선
#### 데이터 분석 서비스 로그
데이터가 추가가 될뿐, 수정은 이루어 지지 않는다
#### 로그 취합 서버
로그 데이터를 잘 취합하여 시스템이 소비할 수 있게 한다
-> 시스템 특성을 고려하여 취합 주기를 결정한다
#### 취합된 데이터
#### 작업 서버
#### 트라이 캐시
분산 캐시 시스템 -> 트라이 데이터를 메모리에 유지하여 성능 개선
##### 트라이 DB
1. 문서 저장소 - 몽고 DB
2. 키-값 저장소 - 접두어를 키로, 캐시 데이터를 밸류
#### 트라이 연산
- 트라이 생성
  작업 서버가 담당, 로그 데이터 이용
- 트라이 갱신
  1. 매주 한번 갱신 하는 방법, 새로운 트라이를 만들어 대체
  2. 트라이 각 노드를 개별적으로 갱신 -> 성능이 좋지 않음
- 검색어 삭제
  혐오성 질의어를 트라이 캐시 앞에 필터 규칙을 두어 반환되지 않도록 한다
#### 저장소 규모 확장
글자를 통해 DB를 샤딩한다 -> 알파벳 빈도수에 따라 균등하지 않다
=> 검색어 대응 샤드 관리자를 두어 알파벳 빈도수에 따라 균등하게 샤딩하게 한다
