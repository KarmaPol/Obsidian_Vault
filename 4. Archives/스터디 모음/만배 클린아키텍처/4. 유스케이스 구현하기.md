## 도메인 모델 구현하기
- 입출금은 객체 지향적으로 Account 엔티티를 만들어서 구현 가능
  -> 결국 입출금은 Activity 추가와 기준 잔고 관리
## 유스케이스 둘러보기
### 일반적 단계
1. 입력을 받는다 -> 입력 유효성은 다른 곳에서
2. **비즈니스 규칙**을 검증한다
3. 모델 상태를 조작한다
4. 출력을 반환한다
## 입력 유효성 검증
- 유즈케이스 클래스의 책임은 아니나 애플리케이션 계층의 책임
- 어댑터에서 검증을 담당하면, 모든 검증을 어댑터에 추가해야함
- 애플리케이션 코어의 바깥쪽의 정보를 믿을수 없다
- Field final로 불변 필드로 만들어 생성 이후 보장
- 생성자에 유효성 검증 추가 가능
- Bean Validation API로 직접 구현 X
- 구문상의 검증(syntactical)
## 생성자의 힘
- 빌더를 활용해도, 필드를 추가하는 상황에서 잊곤 한다
- 생성자를 활용하면 컴파일러 단 오류로 잡아준다
## 유스케이스 마다 다른 입력 모델
- 조금 다르고 비슷한 입력 모델을 퉁쳐서 재사용한다면? 불변 객체에 null
  -> **비즈니스 코드는 신성하다!** 입력 유효성 검사 등으로 오염돼서 안된다
  => 비용이 들더라도 각 유스케이스 전용 입력 모델
## 비즈니스 규칙 검증하기
- 비즈니스 규칙 검증은 확실하게 유즈케이스 로직의 일부
- 의미적인 검증(semantical)
- 가장 좋은 방법은 비즈니스 규칙을 도메인 엔티티 안에 메소드로 집어넣는다
- 도메인 엔티티에서 검증하기 어려우면 유스케이스 코드(서비스)에서 검증한다
## 풍부한 도메인 모델 VS 빈약한 도메인 모델
### 풍부한 도메인 모델
- 어플리케이션 코어 엔티티에 가능한 많은 기능
- 많은 비즈니스 로직과 규칙은 엔티티 내부에 있고, 유즈케이스는 이를 호출
### 빈약한 도메인 모델
- 엔티티는 상태를 표현하는 필드만 표현
- 비즈니스 규칙과 도메인 로직은 유즈케이스 클래스에
## 유스케이스마다 다른 출력 모델
- 출력도 입력과 마찬가지로 유스케이스 마다 구체적이면 좋다
- 유스케이스 간 같은 출력 모델을 공유하게 되면 유스케이스는 강하게 결합된다
- 도메인 엔티티를 입출력 모델로 사용하지 말자
## 읽기 전용 유스 케이스
- 읽기 전용 서비스 "쿼리 서비스"에 읽기 로직을 구현한다
  -> CQS, CQRS 개념과도 잘맞는다
## 어떻게 도움이 될까
- 유스케이스 별로 모델을 공유하지 않는 것은 분명히 더 많은 공수가 든다
  -> 하지만, 유즈케이스를 명확히 이해할수 있고, 장기적으로 유지보수하기 더 쉽다
