분산 시스템에서는 auto_increment와 같은 관계형 DB 기본키를 사용할 수 없다
<- 서버 한대에서는 요구를 감당할 수 없고, delay를 낮추기 매우 힘들다
## 1단계. 문제 이해 및 설계 범위 확정
- ID는 유일
- 숫자로만 구성
- 64비트 표현 값
- 발급 날짜에 따라 정렬 가능
- 초당 10000개의 ID 발급
## 2단계. 개략적 설계안 제시 및 동의 구하기
**분산 시스템 유일성 보장 ID 발급 방법**
- 다중 마스터 복제
- UUID
- 티켓 서버
- 트위터 스노우플레이크 접근법
### 다중 마스터 복제
DB의 auto_increment 기능을 활용하되, k(데이터베이스 서버 수)만큼 증가시킨다
#### 단점
- 여러 데이터 센터에 걸쳐 규모를 늘리기 어려움
- ID 유일성은 보장되지만 시간 흐름에 맞추어 커지도록 보장 불가능
- 서버를 추가하거나 삭제할 때도 잘 동작하게 만들기 어려움
## UUID
UUID는 정보를 유일하게 식별하기 위한 128비트 수
충돌 가능성은 매우 낮음 -> 초당 10억개를 100년 동안 발급해야 중복 확률 50%
각 웹 서버는 별도의 UUID 생성기를 사용
#### 장점
- 단순함
- 규모 확장 쉬움
#### 단점
- ID가 128비트로 김
- 시간순 정렬 불가능
- 숫자가 아닌 값이 포함
### 티켓 서버
auto_increment 기능을 갖춘 DB서버를 중앙 집중형으로 한 개만 사용
#### 장점
- 유일성이 보장되는 숫자로만 구성된 ID 생성
- 구현하기 쉬움
#### 단점
- 티켓 서버가 SPOF
### 트위터 스노우플레이크 접근법
ID를 여러 section으로 분할한다
64비트 = 타임스탬프 + 데이터센터ID + 서버ID + 일련번호
## 상세설계
- 데이터센터 ID, 서버 ID  변경 시 충돌 발생 가능하므로 유의해야함
- 타임스탬프의 경우, 41비트이므로 69년 동안만 정상 작동후 오버플로우 -> 기원 시각을 바꾸거나 ID체계 이전
- 일련번호는 어떤 서버가 밀리초 동안 다수의 ID를 만들때 0보다 큰 값 가짐
### 마무리
#### 추가 논의사항
- 시계 동기화
  여러 대의 서버에서 시간을 어떻게 동기화할 것인가? => NTP(Network Time Protocol)
- section 길이 최적화
  동시성이 낮고, 수명이 긴 어플리케이션의 경우, 일련번호를 줄이고 타임스탬프를 늘리는게 효과적
- 고가용성
  ID 생성기는 필수 불가결 -> 아주 높은 가용성을 제공해야함