## 테스트 피라미드
- 단위 테스트 > 통합 테스트 > 시스템 테스트
- 저비용의 테스트를 많이 만들자
- **유닛 테스트**에서 만약 다른 클래스에 의존하면, Mock으로 대체한다
- **통합 테스트**는 연결된 여러 유닛을 인스턴스화해 기대한 대로 동작하는지 테스트한다
- **시스템 테스트**는 모든 객체 네트워크를 가동시켜 테스트한다
## 단위 테스트로 **도메인 엔티티** 테스트하기
- 간단하게 Account를 인스턴스화해서 메소드를 호출해 성공한지 검증한다
- 유닛 테스트 외 다른 종류의 테스트는 필요없다
## 단위 테스트로 **유스케이스** 테스트하기
- given/when/then 이 일반적이다
- given() 메서드의 Mock 객체를 생성
- then()에서 검증하지만, 상태를 검증할 순 없다
  -> 대신 특정 메서드와의 **상호작용 여부**를 검증한다
- 따라서 코드의 행동, 구조 변경 시 테스트를 변경할 일이 잦아진다
  -> 핵심적인 비즈니스 로직만 작성하자
## 통합 테스트로 **웹 어댑터** 테스트하기
- HTTP를 통해 입력받고, 입력 유효성 검증 뒤 유즈케이스에 전달, 유즈 케이스 결과를 매핑하고 HTTP 응답을 반환하는 것까지 테스트한다
- MockMVC와 같은 통합 테스트 대신 단위 테스트로 컨트롤러만 검증하면 정상 작동을 확신할수 없다
## 통합 테스트로 **영속성 어댑터** 테스트하기
- 데이터베이스를 모킹하지 않고, 실제로 접근한다
- 일반적으로 Spring은 H2 DB를 사용하는것이 편리하지만, 실제 DB 시스템을 대상으로 테스트해야한다 (TestContainers가 용이하다) -> 2가지 DB에 대해 코드를 관리해야할 수 있다
## 시스템 테스트로 주요 경로 테스트하기
- MockMVC가 아니라 TestRestTemplate로 진짜 요청을 보낸다
- 유닛, 통합 테스트에서 발견하지 못한 버그를 찾을 수 있다 (계층간 매핑 버그)
- 도메인 특화 언어로 실제 사용자의 관점에서 테스트할 수 있다
- 여러 개의 유스케이스를 결합한 시나리오에서 더 빛이 난다
## 얼마만큼의 테스트가 충분할까?
- 라인 커버리지 자체는 중요하지 않다
- "얼마나 마음 편하게 소프트웨어를 배포할 수 있느냐"가 중요하다
- 배포 후 버그가 있더라도, 이를 수정하고 배우자
- 기존 테스트가 왜 버그를 잡지 못했는지 기록하고 테스트를 추가하자
- 구현한 뒤가 아닌 **구현할 때** 테스트 코드를 추가하자
- 코드 구조 변경에 너무 취약하면 테스트 코드의 가치를 잃는다
## 어떻게 도움이 될까?
- 육각형 구조에서는 도메인과 어댑터를 깔끔하게 테스트할 수 있다
- 어떤 테스트를 짜야할 지 모르겠다면 아키텍처에 문제가 있다는 경고다