## 객체지향
### 객체
- 객체는 데이터와 메소드로 구성된다
- 객체는 객체마다 자신만의 책임이 있다
- 객체는 서로의 책임을 하며 다른 객체와 의존하며 소프트웨어를 구성한다
ex) 매출 시스템
매출 데이터 읽기 객체 - 매출 집계 객체 - 매출 정산 객체

각 객체는 각자의 책임을 가지며 서로 메시지를 주고 받으며 의존하고 있다
### 객체 책임
- 객체가 가지는 책임을 결정하는 것이 객체 지향 설계의 출발점
- 책임의 크기를 줄이는 쪽이 좋은 패턴
- 객체간 의존성 전이를 줄여야 한다
### 캡슐화
- 객체가 내부적으로 기능을 어떻게 구현했는지 감추는 것
- 내부 구현의 변경이 그 기능을 사용하는 코드에 영향을 받지 않게 한다
  -> 이를 사용하는 외부 구현에는 영향을 미치지 않는다
### 객체 지향 설계 과정
1. 소프트웨어 구현에 필요한 기능을 찾고 이를 세분화한다
2. 세분화된 기능을 알맞은 객체에 할당한다
3. 객체간에 어떻게 메시지를 주고 받을지 결정한다
4. 2, 3번 과정을 반복한다
## DDD
### 도메인 모델
- 도메인은 해당 비즈니스에서 다루는 분야
- 개발자 입장에서는 해결해야할 문제의 분야
- 도메인은 하위 도메인으로 구성
ex) 커머스 - 주문, 결제, 배송, 정산
### 도메인 모델 설계
#### 유비쿼터스 언어
- 도메인 전문가, 개발자가 도메인과 관련된 공통의 언어를 만들어 사용
- 공통의 언어를 코드에 그대로 반영 -> 가독성의 향상
```java
// 공통 언어를 반영하지 않아 협업에 어려움이 있다
public enum OrderStatus {
	STEP1, STEP2, STEP3, STEP4;
}

// 공통의 유비쿼터스 언어 반영
public enum OrderStatus {
	OPENED, ACCEPTED, CANCELLED, CLOSED;
}
```
#### 도메인 모델 도출
- 담당자들간 대화를 통해 도메인을 이해하고, 도메인 모델 초안을 만든다
- 기본이 되는 작업은 핵심 구성요소, 규칙, 기능을 찾는 것
#### 문서화
도출된 도메인은 다양한 형태의 다이어그램(ex. 클래스 다이어그램)으로 문서화하여 공유한다
#### 도메인 영역 주요 구성요소
- **엔티티 ENTITY**
  고유의 식별자를 갖고 라이프 사이클을 가짐
  주문, 회원 등 도메인의 고유한 개념을 표현
  데이터와 함께 기능을 제공
- **밸류 VALUE**
  하나의 값, 엔티티의 속성
- **애그리거트 AGGREGATE**
  엔티티와 밸류를 개념적으로 하나로 묶은 것
- **REPOSITORY**
  도메인 모델의 영속성을 처리
  DBMS에서 엔티티를 불러오거나 저장
- **도메인 서비스**
  엔티티에 속하지 않은 도메인 로직 제공
  ex. 할인 금액 계산은 상품 + 쿠폰 + 회원 등 다양한 도메인을 이용해 구현
#### 애그리거트
복잡한 도메인을 이해하고 관리하기 쉽게 **상위 수준**에서 도메인을 묶어주는 것

개별 모델 수준에서 도메인 모델을 파악하면 너무 복잡하다
=> 개별 모델을 상위 수준으로 '애그리거트' 단위로 묶어 도메인 모델간 관계 파악
(ex. 주문 애그리거트, Orderer-Order-OrderLine-ShippingInfo-Address)

애그리거트에 속한 도메인 모델들은 일관성을 유지하고, 루트 도메인을 통해서만 변경되어야 한다
Orderer, Address 엔티티에 따로 접근하지 않고, **루트 도메인인 Order을 통해 접근한다**
-> Repository도 애그리거트 단위로
#### 바운디드 컨텍스트
- 도메인 영역의 경계
- 도메인 영역 경계의 기준은 유비쿼터스 용어의 개념이 달라지는 곳을 기준으로 경계를 나눈다

같은 소비자여도 **결제 컨텍스트**에서는 **결제자**로, **배송 컨텍스트**에서는 **수취자**로
## 우아콘 강의)