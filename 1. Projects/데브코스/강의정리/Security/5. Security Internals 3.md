## 지난 미션 리뷰
### AccessDecisionVoter 커스텀
AccessDecisionVoter의 구현체 추가
```java
// OddDecisionVoter.class
public class OddDecisionVoter extends AccessDecisionVoter<Filter> {

	...
	@Override
	public int vote (Authentication authentication, FilterInvocation fi, Collection<ConfigAttribute> attributes) {
		HttpServletRequest request = fi.getRequest();
		// url이 /admin이 아니면 통과
		if(!requiresAuthorization(request)) {
			return ACCESS_GRANTED;
		}
		User user = (User) authentication.getPrincipal();
		// 유저 이름 홀수 인지 체크
		...

		return ACCESS_DENIED;
	}
}

// WebSecurityConfigure.class
public WebSecurityConfgiure {
	@Bean
	public AccessDecisionManger accessDecisionManager(){
		List<AccessDecisionVoter<?>> voters = new ArrayList<>();
		voters.add(new OddAdminVoter(new AntPathRequestMatcher("/admin")));
		return new UnanimousBased(voters);
	}

	...
}
``` 
AccessDecisionManger을 SecurityConfig에서 빈으로 등록한다
-> OddDecisionVoter을 voters에 추가해 UnanimousBased로 리턴
## 인증 이벤트
AbstractAuthenticationEvent - 스프링 시큐리티 최상위 이벤트

이벤트를 사용하면 모듈 간 결합도를 낮출 수 있다
#### 이벤트를 사용하지 않을 경우
- successfulAuthentication()
  AbstractAuthenticationProcessingFilter의 successfulAuthentication를 오버라이드
  -> 인증 성공 시 수행할 메소드 지정
```java
// CustomAbstractAuthenticationProcessingFilter.class
protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws Exception {
	sendEmail(authResult); // 이메일 전송
	super.successfulAuthentication
}
```
만약 성공시 sms 전송 로직이 추가된다면, 추가 로직마다 코드를 수정해줘야 한다
#### 이벤트를 사용할 경우
```java
// CustomAuthenticationEventHandler.class
@EventListener
public void handleAuthenticationSuccessEvent(AuthenticationSuccessEvent event) {
	Authentication authentication = event.getAuthentication();	
}

@EventListener
public void handleAuthenticationFailureEvent(AbstractAuthenticationFailureEvent event) {
	Authentication authentication = event.getAuthentication();
}
```
클래스에 override해 로직을 추가하는 대신, 이벤트 수신자를 추가해줄 수 있다 
- @Async 비동기 처리
```java
// CustomAuthenticationEventHandler.class
@Async
@EventListener
public void handleAuthenticationSuccessEvent(AuthenticationSuccessEvent event) {
	Authentication authentication = event.getAuthentication();	
}
```
로그인 처리와 로그인 성공 이벤트를 별도의 스레드에서 동시에 처리할 수 있다