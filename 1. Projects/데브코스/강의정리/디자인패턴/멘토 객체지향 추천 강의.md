## 객체지향 언어

1. 대체가능성 : 하위형은 상위형을 대체할 수 있음
2. 내적동질성 : 어떤 형으로 객체 참조해도 원래 형으로 작동 (Parent child = new Child(), override한 child의 메소드가 나옴)

객체지향의 실체는 상속, 클래스가 아니다

## 객체지향 프로그래밍

객체는 협력을 위해 메세지를 주고 받는다.

어떤 문제를 해결할때 객체 간의 협력으로 해결한다.

변화율에 따라(SRP) 코드를 역할(OCP)로 나누고, 역할에 맞는 객체를 만든 뒤(LSP - 자식은 언제나 부모로 대체 가능) 코드를 **최대한 다른 객체에게 떠민다**.

순환 의존을 피해라

부모 객체가 의존하는지, 자식 객체가 의존하는지에 따라 많은 차이가 난다.

유연한 설계는 딱딱한 설계를 대체할 수 있지만, 그 반대는 힘들다

즉 **객체지향에서의 유연한 설계**란 함수나 고정 필드로 선언할 것을 인스턴스화해서 소유하는 것

- 참조 컨텍스트
    
    객체의 메모리 주소로 객체를 식별
    
    값으로 식별하는 것은 값 컨텍스트, 객체지향적이지 않다.
    
    무조건 참조 컨텍스트만 써야하는 것은 아니다 ⇒ 문맥을 잘 파악하라
    

### 템플릿 메소드 패턴 - 상속

특정 로직이 구상 클래스, 추상 클래스에 들어가야할지 고민해라

⇒ 모든 자식에 공통적으로 들어갈 로직이라면 추상 클래스로 빼고, 자식마다 다른 메소드를 추상 메소드로 선언

[https://refactoring.guru/ko/design-patterns/template-method](https://refactoring.guru/ko/design-patterns/template-method)

템플릿 메소드는 오버라이딩할 수 없지만, 내부 단계인 메소드들은 오버라이딩 할 수 있다.

### 전략 패턴 - 합성

템플릿 메소드 패턴 ←→ 전략 패턴 기계적 변환이 가능하다

상속 대신 합성을 사용하면 복잡한 클래스 구조물들을 만들 필요가 줄어든다

전략 자체를 인스턴스로 받아 처리한다. ⇒ 자식 클래스를 몰라도 된다

[https://refactoring.guru/ko/design-patterns/strategy](https://refactoring.guru/ko/design-patterns/strategy)

### 템플릿 메소드 vs 전략 패턴

사용하는 코드만 보고 파악하기에는 템플릿 메소드 패턴이 유리

따라서 대규모 시스템에서는 템플릿 메소드, 소규모에서는 전략 패턴 경향
### 도서 오브젝트 요약
https://devroach.tistory.com/56?fbclid=IwAR1n21Q7zyEvSA0lBscEfnUFz9TAxjUSVAqBkOjDr-u4-mIi6yYirGfE2Mg