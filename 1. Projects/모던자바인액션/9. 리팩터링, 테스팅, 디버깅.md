## 리팩터링
- 익명 클래스보다 코드를 간결하게 만듬
### 코드 가독성 개선
- 익명 클래스 -> 람다 표현식
- 람다표현식 -> 메서드 참조
- 명령형 데이터 처리 -> 스트림
#### 익명 클래스를 람다 표현식으로 리팩터링하기
- AS IS
```java
Runnable r1 = new Runnable() {
	public void run(){
		System.out.println("Hello");
	}
};
```
- TO BE
```java
Runnable r2 = () -> System.out.println("Hello");
```
#### 함수형 인터페이스 모호함 문제
```java
interface Task {
	public void execute();
}
public static void doSomething(Runnable r){ r.run(); }
public static void doSomething(Task a){ r.execute(); }

// client
doSomething(() -> System.out.println("Danger!!")); 
// doSomething(Runnable)? doSomething(Task)?
```
- 해결책
```java
doSomething((Task)() -> System.out.println("Danger!!"));

```
#### 람다 표현식을 메서드 참조로 리팩터링하기
- AS IS
```java
Map<CaloricLevel, List<Dish>> dishesByCaloricLevel =
	menu.stream()
		.collect(
			groupingBy(dish -> {
				if (dish.getCalories() <= 400) return CaloricLevel.DIET;
				else return CaloricLevel.FAT;
			})
		)
```
- TO BE
```java
Map<CaloricLevel, List<Dish>> dishesByCaloricLevel =
	menu.stream().collect(groupingBy(Dish::getCaloricLevel));
```

- comparing, mayBy도 유용하다
```java
(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());

comparing(Apple::getWeight);
```

- 내장 컬렉터를 활용하자
```java
.reduce(0, (c1, c2) -> c1 + c2);

.collect(summingInt(Dish::getCalories));
```
#### 명령형 데이터 처리를 스트림으로 리팩터링하기
- AS IS
```java
for(Dish dish: menu) {
	if(dish.getCalories() > 2300) {
		dishNames.add(dish.getName());
	}
}
```
- TO BE
  직관적이고 쉽게 병렬화 가능하다
```java
menu.parallelStream()
	.filter(d -> d.getCalories() > 300)
	.map(Dish::getName)
	.collect(toList());
```
#### 코드 유연성 개선
- 외부에 조건을 노출하지 않고 람다로 **특정 조건, 특정 행동 지정** 가능
```java
if(logger.isLoggable(Log.FINER)) {
	logger.finer("log~~");
}

// TO BE
logger.log(Level.FINER, () -> "log~~");
```
# 람다로 객체지향 디자인 패턴 리팩터링하기
## 전략
- 런타임에 적절한 알고리즘을 선택하는 기법
- 클라이언트/전략 인터페이스/전략 구현체
### 람다 표현식 사용
```java
Validator numbericValidator =
	new Validator((String s) -> s.matches("[a-z]+"));
boolean b1 = numericValicator.validate("aaa");
Validator lowerValidator = 
	new Validator((String s) -> s.matches("\\d+")); // 전략 구현체 직접 전달
```
## 템플릿 메서드
- 알고리즘 개요 제시 후 수정 가능한 유연함 제공시 사용
```java
// 온라인 뱅킹
abstract class OnlineBanking {
	public void processCustomer(int id) {
		Customer c = Database.getCustomerWithId(id);
		makeCustomerHappy(c);
	}
	abstract void makeCustomerHappy(Customer c); // 상속받아 수정
}
```
### 람다 표현식 사용
```java
public void processCustomer(int id, Consumer<Customer> makeCustomerHappy) {
	Customer c = Database.getCustomerWithId(id);
	makeCustomerHappy.accept(c);
}
```
- 상속 대신 람다 표현식 전달해 수행 가능
## 옵저버
- 한 객체가 다른 객체 리스트에 자동으로 알림
- Subject와 Observer 인터페이스의 구현체 리스트로 알림 구현
### 람다 표현식 사용
```java
Feed f = new Feed();

f.registerObserver((String tweet) -> {
	if(tweet != null && tweet.contains("money")) {
		System.out.println(tweet);
	}
})
```
- **Observer을 명시화하는 대신 메서드만** 전달 가능하다
  -> 내부 구현이 복잡하면 기존 방식이 더 좋다
## 의무 체인
- 객체 작업 처리 후 다른 객체로 전달
```java
public abstract class ProcessingObject<T> {
	protected ProcessingObject<T> successor; // 다음 객체
	public void setSuccessor(ProcessingObject<T> successor) {
		this.successor = successor;
	}
	public T handle(T input) {
		T r = handleWork(input);
		if(successor != null) {
			return successor.handle(r);
		}
		return r;
	}
	abstract protected T handleWork(T input);
}
```
### 람다 표현식 사용
```java
UnaryOperator<String> headerProcessing =
	(String text) -> "From" + text;
UnaryOperator<String> spellCheckProcessing =
	(String text) -> text.replaceAll("labda", "lambda");
Function<String, String> pipeline = 
	headerProcessing.andThen(speelCheckerProcessing); // 동작 체인으로 조합
```
## 팩토리
- 인스턴스화 로직을 클라이언트에 공개하지 않고 객체 생성
```java
public class ProductFactor {
	public static Product createProduct(String name) {
		switch(name) {
			case " loan" : return new Loan();
			...
		}
	}
}
```
### 람다 표현식 사용
```java
Supplier<Product> loanSupplier = Loan::new;

final static Map<String, Supplier<Product>> map = new HashMap<>();
static {
	map.put("loan", Loan::new);
	map.put("stock", Stock::new);
}
```
- **Supplier** 참조 + Map으로 팩토리 패턴 대체 가능
  -> 단, **생성자 매개변수 많아질수록 복잡**해 고려해야함