## TCP 커넥션
HTTP 통신은 TCP/IP 프로토콜을 통해 이루어진다
- 이때 메시지들은 손실, 손상되거나 순서가 바뀌지 않는다
- 메시지는 세그먼트 단위로 나뉘어 IP 패킷에 담겨 전달된다
	- IP 패킷 구성 - IP 패킷 헤더(IP주소), TCP 세그먼트 헤더(포트번호), TCP 데이터 조각
- 커넥션은 (발신지 IP, 발신지 포트, 수신자 IP, 수신자 포트)로 식별 -> 유일한 값
### TCP 소켓 프로그래밍
유닉스 및 대부분의 운영체제에서 사용 가능
- 소켓 API
  s = socket(), bind(s, IP:port), close(s)...
- 소켓 API로 TCP 종단 데이터 구조를 생성해 데이터 스트림을 읽고 쓸 수 있다
  -> 이때 핸드셰이킹, TCP 스트림, IP 패킷 분할 등 세부사항은 숨긴다
### TCP 성능 고려
- HTTP 트랜잭션 성능은 TCP 성능에 영향을 받는다
#### HTTP 트랜잭션 지연
TCP 지연에 비해 트랜잭션 처리 시간 자체는 매우 짧음
##### 지연원인
- DNS 검색 시간
- TCP 연결 시간
- 클라이언트 -> 서버 메시지 전송 시간
- 서버 -> 클라이언트 메시지 전송 시간
### TCP 관련 지연
#### TCP 커넥션 핸드셰이크 지연
커넥션 생성시
1. 클라이언트 -> 서버 SYN
2. 서버 -> 클라이언트 SYN + ACK
3. 클라이언트 -> 서버 ACK + 메시지
이러한 과정은 정작 HTTP 메시지에 비해 큰 경우가 많다 -> 커넥션 재활용
#### 확인 응답 지연
수신자가 TCP 세그먼트를 온전히 받으면 송신자에게 확인 응답 패킷 반환
- **확인 응답 지연 알고리즘**
  TCP 확인 응답 메시지를 데이터 패킷에 '편승'
  일정 시간 동안 대기하면서 편승할 패킷 찾음
  -> HTTP 특성 상 기회가 많지 않음 -> 오히려 성능 저하
#### TCP slow start
TCP는 급작스러운 부하를 막고자 연결을 맺고 점차 속도 제한을 높여 나간다
- **opening the congestion window**
  1개를 보내고 ACK를 받으면 2개, 2개를 보내고 ACK를 받으면 4개..
#### 네이글 알고리즘
네트워크 효율을 위해 많은 양의 TCP 데이터를 한 개의 덩어리로 합친다
- 문제점
  1. 작은 데이터의 경우, 추가적인 데이터를 무작정 기다리게 됨
  2. 다른 모든 패킷이 확인 응답을 받을때 최대 크기보다 작은 패킷 전송을 허용하는데,
     확인 응답 지연 알고리즘은 확인 응답을 100~ 200밀리초 지연시킨다
#### TIME_WAIT 누적과 포트 고갈
TCP 연결을 끊으면 해당 커넥션 정보를 control block에 기록
<- 같은 IP주소와 포트를 갖는 커넥션을 2MSL(약 2분) 동안 생기는 것을 방지

이때 성능 시험과 같이 IP 주소를 제한할 경우, 연결의 조합이 제한된다
-> TIME_WAIT가 누적되어 포트를 바로 재활용하는 것이 어려워진다
### HTTP 커넥션 관리
#### Connection 헤더
- HTTP 헤더 필드는 해당 커넥션에서만 사용하고 삭제
- close 값은, 작업 종료 시 커넥션도 종료되어야함을 의미
#### 순차적인 트랜잭션 처리에 의한 지연
커넥션 맺고, 리소스 요청-응답 과정을 순차적으로 반복
->모든 객체를 내려받기 전까지 텅 빈 화면만 출력
=> 병렬, 지속, 파이프라인, 다중 커넥션으로 해결 가능
### 병렬 커넥션
여러 개의 커넥션을 한번에 맺고 동시에 다운
- 일반적으로 빠르지만 네트워크 대역폭 자체가 좁으면 성능 상 장점이 사라지고, 
  커넥션 갯수가 너무 많으면 성능 과부하 가능
- 항상 더 빠르게 로드하지 않음에도 화면 상으로 더 빠르게 느껴짐
### 지속 커넥션
앞으로도 있을 HTTP 요청에 TCP 커넥션을 재활용 -> TCP 커넥션 지연 및 slow start 회피
- 병렬 커넥션과 함께 사용하는 것이 효과적
#### Keep-Alive
HTTP/1.0의 지속 커넥션 타입, 1.1버전에서 제거되었음에도 아직 많이 사용
헤더에 Connection: Keep-Alive 포함
Keep-Alive: max=5, timeout=120 옵션 파라미터 설정 가능
- **Dumb Proxy**
  프락시는 keep-alive를 이해하지 못하고 그대로 서버로 보낸다
  -> 서버는 프락시가 지속 커넥션을 맺었다고 이해
  -> 정작 프락시는 커넥션이 끊어질 때까지 대기
  -> 클라이언트에서 다시 요청을 보내면 프락시는 해당 요청을 무시하고 대기 => 장애 발생
- **Proxy Connection**
  영리한 프락시를 위한 확장헤더
  클라이언트와 지속 커넥션을 하고, 서버에는 Connection 헤더만 전달한다
  이때 영리한 프락시는 Connection 헤더는 무시한다
  -> 하지만, 프락시를 여러개 사용하면 멍청한 프락시가 껴있을 수 있다.. => 같은 문제 발생
#### HTTP/1.1 지속 커넥션
keep-alive를 지원하지 않는다
Connection: close 헤더가 없으면 응답 후에도 유지하는 것으로 간주
### 파이프라인 커넥션
여러 개의 요청을 큐에 쌓고, 응답이 도착하기 전에 다음 요청 송신
- 지속 커넥션을 확인하기전에 파이프라인 X
- HTTP 응답은 요청 순서에 맞게 와야한다
- 중간에 커넥션이 끊어지더라도 다시 요청을 보낼 준비가 되어야한다
- 비멱등 요청을 파이프라인으로 보내면 안된다
### 커넥션 끊기
#### 마음대로 끊기
서버, 클라이언트, 프록시에서 마음대로 끊을 수 있음
-> 클라이언트가 요청을 보내는 중이었다면 문제 발생
#### Content-Length와 Truncation
커넥션이 끊어졌을 때, 실제 전달된 엔티티 길이와 Content-Length가 일치하지 않으면 서버에 확인해야한다
캐시 프락시의 경우, 캐시하거나 Content-Length를 정정하지 말고 메시지를 그대로 전달해야한다
#### 커넥션 끊기의 허용, 재시도, 멱등성
커넥션이 예상치 못하게 끊어졌을때, 비멱동성 메서드를 보내면 알 수 없는 결과를 초래한다
-> 이전 요청에 대한 응답을 받을 때까지 기다리고, 요청을 다시 보내길 원하는 대화상자를 보여줘야한다
#### 우아한 커넥션 끊기
- TCP 커넥션은 입, 출력 채널을 따로 끊을 수 있다
- 예상치 못한 결과를 방지하기 위해 출력 채널을 끊는게 안전하다
  -> 입력 채널을 먼저 끊으면, 끊긴 채널에 도착한 데이터에 의해 OS 에러 발생
  => 자신의 출력 채널을 먼저 끊고, 다른 쪽 출력 채널이 끊기는 것을 기다리는 것이 가장 안전
  -> 하지만, 상대방이 절반 끊기를 하는지 보장이 없으므로 내 입력 채널 상태 검사를 하다가 타임아웃 후 끊기