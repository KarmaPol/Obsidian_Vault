자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치
## 캐시의 혜택
### 불필요한 데이터 전송
원 서버가 중복해서 다수의 클라이언트와 트래픽을 주고 받는 낭비를 줄일 수 있음
### 대역폭 병목
광역 대역폭의 특성 상 네트워크 속도 저하
-> 빠른 LAN에 있는 캐시로부터 사본을 가져오면, 성능 대폭 개선
### 갑작스런 요청 쇄도
갑작스러운 트래픽 증가에 의한 웹 서버 장애 방지 가능
### 거리로 인한 지연
빛의 속도 그 자체가 유의미한 지연 유발 (보스턴 - 샌프란시스코 1/4초 지연)
-> 근처 지역에 캐시를 설치하면 거리 지연 해결 가능
## 적중과 부적중
- Cache Hit 캐시 적중
  캐시 요청에 대응하는 사본이 캐시에 있으면 적중
- Cache Miss 캐시 부적중
### 재검사
- 원 서버 콘텐츠는 변경될 수 있기 때문에 사본이 최신 버전인지 점검해야한다
-> 이를 '신선도 검사'를 HTTP 재검사라고 한다
- 캐시에 저장하는 사본의 개수는 매우 많기 때문에 사본이 검사할 정도로 충분히 오래되었을 때만 재검사를 진행한다
- 재검사가 필요할때, 속도 = 캐시 히트 > 성공한 재검사 > 캐시 미스 = 실패한 재검사
- 사본이 유효할 경우, 304 Not Modified 응답을 보낸다
### 적중률
캐시가 요청을 처리하는 비율, 0부터 1까지의 값
40% 정도면 괜찮다
### 바이트 적중률
모든 문서의 크기가 같지 않기 때문에 모든 바이트의 비율을 표기하기에 용이하다
### 적중과 부적중의 구별
HTTP 응답 코드 자체는 200 OK 로 동일하다
-> 응답 Date 헤더 값과 현재 시각을 비교하여 캐시된 값인지 알 수 있다
## 캐시 토폴로지
### 개인 전용 캐시
웹 브라우저 - 개인 전용 캐시 내장, 작고 저렴함
### 공용 프락시 캐시
특별한 종류의 프락시 서버
- 로컬 캐시에서 문서를 제공하거나
- 클라이언트 입장에서 서버에 접근
=> 불필요한 네트워크 트래픽을 줄일 수 있다
### 프락시 캐시 계층들
캐시를 계층으로 나누어 
- 클라이언트 주위에는 작고 저렴한 캐시
- 서버 주위에는 비싸고 강력한 캐시
### 캐시망, 콘텐츠 라우팅, 피어링
- 네트워크 아키텍처에서 복잡한 캐시망 구성
-> 요청을 원 서버로 보낼지 어떤 부모 캐시로 보낼지 동적으로 결정
- 다른 캐시들 끼리 부분적인 접근만 허용, 
  인터넷 트랜짓(트래픽이 다른 네트워크로 건너가는 것)은 허용 X
- 서로 다른 조직들이 상호 이득을 위해 그들의 캐시를 연결하여(형제 캐시) 찾아볼 수 있게 해줌
## 캐시 처리 단계
### 1. 요청 받기
네트워크 커넥션에서 활동을 감지하고 들어오는 데이터를 읽는다
### 2. 파싱
요청 메시지를 헤더 부분을 조작하기 쉬운 자료 구조에 담는다
### 3. 검색
URL을 통해 로컬 사본이 있는지 검색한다
상황에 따라 원 서버나 부모 프락시에서 가져온다
얼마나 캐시에 머무르고 있었는지, 얼마나 자주 사용되는지 등 메타 데이터 포함
### 4. 신선도 검사
너무 오래 가지고 있었다면 원 서버에 재검사
### 5. 응답 생성
원 서버의 응답 헤더를 토대로 응답 헤더 생성
캐시 신선도 정보(Cache-Control, Age, Expires..)를 삽입하며, 
프락시 캐시를 거쳤다는 걸 알려주고자 종종 Via 헤더 삽입
Date 헤더는 최초 생성일자를 나타내므로 조정하면 안된다
### 6. 전송
응답 헤더가 준비되면 클라이언트에 응답을 돌려준다
### 7. 로깅
로그 파일과 캐시 사요에 대한 통계 유지
캐시 히트, 미스에 대한 통계 갱신
## 사본을 신선하게 유지하기
### 문서 만료
HTTP는 Cache-Control, Expires라는 특별한 헤더들을 이용해서 각 문서에 유효기간 붙일 수 있다
만료되면 반드시 재검사
### 유효기간과 나이
- HTTP/1.0+ Expires
- HTTP/1.1 Cache-Control:max-age
### 서버 재검사
캐시된 사본 만료 시 재검사
- 원본 변경 시, 새로운 사본을 갱신하고 클라이언트에 전송
- 원본 변경 X, 새 헤더들만 가져와 캐시 헤더만 갱신
### 조건부 메서드와의 재검사
GET 요청 메시지에 특별한 조건부 헤더를 추가하여 재검사를 효율적으로 처리
- If-Modified-Since 날짜 재검사
- If-None-Match 엔티티 태그 재검사 - 대응하는 엔티티 변경 시 태그 갱신
## 캐시 제어
문서가 만료되기 전까지 얼마나 오랫동안 캐시될 수 있게 할 것인지 설정
### no-cache와 no-store 응답 헤더
Cache-Control : no-store, no-cache 헤더는 검증되지 않은 캐시된 객체로 응답하는 것을 막는다
- no-store 캐시가 응답의 사본을 만드는 것을 금지
- no-cache 로컬 캐시 저장소에 저장 가능, 캐시에서 클라이언트 제공 시 반드시 재검사
### Max-Age 응답 헤더
Cache-Control : max-age=3600
초 단위로 최대 age 지정
### Expires 응답 헤더
Expires : Fri, 05, Jul 2002, 05:00:00 GMT
초 단위 시간 대신 실제 만료 날짜 명시
### Must-Revalidate 응답 헤더
Cache-Control : must-revalidate
캐시 성능을 위해 만료된 객체도 제공할 수 있는데, 이때 만료 객체 제공을 근원적으로 방지한다
### 휴리스틱 만료
응답이 어떤 캐시 제어 헤더도 갖고 있지 않다면, 경험적인 방법으로 최대 나이를 계산
## 클라이언트 신선도 제약
Cache-Control 요청 헤더를 이용해 브라우저, 프락시 캐시 만료를 더 엄격하게 할 수 있음
(Cache-Control: max-stale, min-fresh, no-cache ..)
### 문서 만료 주의할 점
만약 유효기간을 까마득한 미래로 설정하면 어떤 변경도 캐시에 반영되지 않는다
## 캐시와 광고
캐시는 사용자를 도와 더 좋은 경험을 제공하고, 네트워크 사업자가 트래픽을 줄일 수 있게 해준다
### 광고 회사의 딜레마
캐싱이 완벽하게 동작하면 원 서버 HTTP 접근을 캐싱 서버가 모두 흡수한다
-> 접근 횟수에 따라 돈을 벌면 달갑지 않은 일이다
### 퍼블리셔의 응답
광고를 CGI 게이트웨이를 통해 제공해 캐시 무력화 -> 매 접근 마다 광고 URL을 고쳐 씀
- 이상적으로는 캐시가 흡수하도록 내버려 두고 캐시 적중을 광고 회사에 알린다
  -> 모든 접근에 대해 원 서버와 재검사하도록 캐시 설정 
  => 캐시와 동시에, 원 서버에서 적중도 확인, But 트래픽을 증가시킨다
### 로그 마이그레이션
캐시 적중 로그를 서버에 제공한다 -> 크기 때문에 옮기기 어ㄹ움
### RFC 2227, Meter 헤더
특정 URL에 대한 캐시 적중 횟수를 정기적으로 서버에 돌려주는 Meter 헤더를 추가







