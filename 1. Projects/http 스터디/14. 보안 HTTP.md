HTTP 보안 기술은 다음을 제공해야한다
- 서버 인증
- 클라이언트 인증
- 무결성
- 암호화
- 효율
- 편재성
- 관리상 확장성
- 적응성
- 사회적 생존성
### HTTPS
HTTP 하부에 전송 레벨 암호 보안 계층 제공
SSL 또는 TLS
### 디지털 암호학
#### 대칭키 암호
발송자와 수신자 모두 통신을 위해 비밀 키 k를 똑같이 공유
DES, Triple-DES, RC2
#### 키 길이와 열거 공격
40비트 대칭키 암호는 무차별 대입으로 몇 초만에 해독
#### 공유키 발급하기
N명이 서로 공유키를 발급하면 대략 N^2개의 공유키가 필요
이를 일일히 관리하기 어려움
### 공개키 암호
X에게 보내는 메시지는 X의 공개키로 암호화
X는 받은 메시지를 비밀키로 디코딩 -> 다른 사람은 디코딩할 수 없다

공개키 암호는 계산이 느린경향이 있어,
채널 수립은 공개키로, 채널 수립 이후엔 대칭키를 섞어서 사용
### 디지털 암호
메시지에 붙어있는 특별한 암호 체크섬
-> 저자의 개인키로만 체크섬을 계산할 수 있으므로 위조 방지
### 디지털 인증서
CERTS 기관으로부터 보증받은 사용자, 회사에 대한 정보를 담음
#### 인증서 내부
- 대상 이름
- 유효 기간
- 인증서 발급자
- 인증서 발급자의 디지털 서명
## HTTPS
URL이 HTTPS 스킴을 갖고 있다면
- 클라이언트는 서버에 443번 포트로 연결
- SSL 보안 매개변수를 교환하며 핸드셰이크
### 보안 전송 셋업
1. 서버 443 포트로 TCP 커넥션 수립
2. SSL 매개변수 핸드셰이크
3. 클라이언트 : SSL을 통해 보낸 HTTP 요청 -> TCP를 통해 보내진 암호화된 요청
4. 서버 : SSL을 통해 보낸 HTTP 응답 -> TCP를 통해 보내진 암호화된 응답
5. SSL 닫힘 통지
6. TCP 커넥션 닫힘
### SSL 핸드셰이크
- 프로토콜 버전 번호 교환
- 양쪽이 알고 있는 암호 선택
- 양쪽 신원 인증
- 채널 암호화하기 위한 임시 세션 키 생성
### 진짜 HTTPS 클라이언트
SSL 트래픽을 직접 보내는 것은 매우 복잡 -> 라이브러리를 사용해라
- OpenSSL
### 프락시를 통한 보안 트래픽 터널링
프락시는 암호화된 요청의 HTTP 헤더를 읽을 수 없다
- HTTPS SSL 터널링 프로토콜
CONNECT 확장 HTTP 메소드를 통해 커넥션 수립
-> 핸드셰이크 성공 시 데이터가 직접적으로 오가는 터널 수립, SSL 데이터 전송 시작
