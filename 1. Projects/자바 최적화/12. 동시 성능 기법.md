- 하드웨어 의존적 공짜 점심은 끝났다
## 병렬성
### 암달의 법칙
- 병렬 프로세서를 무한히 증가시켜도 순차 작업 시간 이상 줄일 수 없다

- 자바에서 락, synchronized 등으로 감싸지 않으면 업데이트 유실 등 문제가 발생한다
  -> 동시 프로그램의 버그나 실패를 증명하는 것도 매우 어렵다
## JMM
- 자바 5와 함께 배포된 메모리 모델
- synchronized 주로 사용
### 메모리 모델 고수준 접근 방식
1. 강한 메모리 모델
   전체 코어가 항상 같은 값을 바라봄
   **-> 직관적이지만 멀티코어 시스템에 맞지 않다**
2. 약한 메모리 모델
   코어마다 다른 값을 바라볼수 있고, 이를 제어하는 캐시 규칙 존재

### JMM의 기본 동작 개념
1. Happens-Before
   한 이벤트는 무조건 다른 이벤트보다 먼저 발생
2. Synchronizes-With
   이벤트가 객체 뷰를 메인 메모리와 동기화
3. As-If-Serial
   실행 스레드 밖에서는 명령어가 순차 실행되는것처럼 보인다
4. Release-Before-Acquire
   한 스레드에 걸린 락을 다른 스레드가 그 락을 획득하기 전에 해제
-> Transaction의 원자성과 유사하다고 느낌

#### synchronized 의 의미
- 스레드의 로컬 뷰가 메인 메모리가 동기화됐다
  -> 스레드가 반드시 동기화하는 접점을 정의
### 기존 synchronized 락의 한계점
- 락이 걸린 객체에서 일어나는 동기화 작업은 모두 균등히 취급
- 락 획득, 해제는 반드시 메서드 수준이나 메서드 내부 동기화 블록 수준
- 락을 얻지 못한 스레드는 블로킹됨. 락을 얻어 처리를 계속하려고 시도하는 것조차 불가능함

- 다른 스레드가 업데이트한 내용을 바라보게 하려면 읽기 작업에도 synchronized 사용 필요

-> JMM은 아주 좋지만 이해하기 어렵고 유연성이 떨어진다
=> 자바 동시성 라이브러리의 등장
## 동시성 라이브러리
- CAS
  예상되는 현재값 - 원하는 새 값을 메모리 위치를 전달받아 비교 후 교체하는 동작
### Unsafe
- 표준 자바 플랫폼 API X
- 아토믹 연산
- 락과 스핀락 지원
## 동시 라이브러리 정리
### java.util.concurrent
자바 5부터는 일반화한 락으로 인트린직 락보다 더 많은 일을 할수 있음
- lock()
- newCondition()
  락 주위에 조건 설정해 좀더 유연하게 락 사용
- tryLock()
- unlock()

 - 읽기 쓰기 락
 - 세마포어
 - 동시 컬렉션
   ConcurrentHashMap -> 특정 세그먼트만 락을 거는 행위도 가능
- 래치와 배리어
## 실행자와 태스크 추상화
- 사실 저수준 프로그래밍보다는 추상화된 동시 프로그래밍 기능을 사용하자
### 비동기 프로그래밍
- Callable로 비동기 태스크 생성
- ExcecutorService로 스레드 풀 생성하여 Callable 실행
- 포크/조인으로 더 작은 서브태스크로 분할해 '낯간지러운 병렬' 수행 가능
