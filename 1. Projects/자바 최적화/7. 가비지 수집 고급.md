# 트레이드 오프와 탈착형 수집기
- GC는 탈착형, 완벽한 범용형은 없음
	- 중단시간
	  -> 예로 배치 처리 시스템은 중단시간보다 처리율이 중요
	- 처리율
	- 중단 빈도
	- 회수 효율
	- 중단 일관성
# 동시 GC 이론
- GC 개입 시점을 알수 없다
## JVM 세이프 포인트
 - 세이프 포인트
   스레드 내부 자료 구조가 노출된 지점
- 어플리케이션 스레드들은 thread barrier에 도달해 대기, 지속적으로 폴링하며 체크
### JVM 세이프 포인트 규칙
1. JVM은 스레드를 강제로 세이프포인트 상태로 바꿀수 없다
2. JVM은 스레드가 세이프포인트 상태에서 벗어나지 못하게 할 수 있다
### 삼색마킹 알고리즘
- 회색마크 순회하며 자식 노드에 회색마크 퍼뜨리고, 검정마크로 방문 체크
- 병렬 작업시, 검정마크와 연결된 흰색마크 객체가 새로 생성되어 문제발생
  -> 변경자 스레드가 검정마크- 회색으로 수정
## CMS 수집기
- 중단 시간을 아주 짧게 하게 하려고 설계된 테뉴어드용 GC
- **어플리케이션 스레드와 같이 작동**, 따라서 처리율, 중단시간 낮음 -> 저지연 어플리케이션에 특화
- 단편화를 하지 않음, 조기승격이 너무 잦아 테뉴어드도 부족한 경우(CMF) 
  => ParallelOld GC로 풀STW
```java
-XX:+UseConcMarkSweepGC
```
# G1 수집기
[로그로 G1 동작 확인하기](https://chaewsscode.tistory.com/261)
- 자바8 이후의 GC, 오라클에서 집중
- CMS 보단 중단시간이 길다
- 통계적 압착
### 장점
- CMS보다 훨씬 튜닝하기 쉬움
- 조기 승격에 덜 취약
- **중단시간 적고**, FULL STW 거의 없음
## G1 힙 레이아웃 영역
- Region
  힙 내부 1 MB(default) 메모리 공간
- 힙을 Region으로 나누어 각 **세대별 불연속 배치** 가능
## G1 알고리즘 설계
- G1은 가비지를 얼마나 수집할수 있는지 통계적으로 추측해 할당과 비교
- 기존 카드테이블과 유사하게 Rset 사용, 레퍼런스 저장
## G1 단계
[G1 단계 상세 설명](https://youn0111.tistory.com/67)
![[Pasted image 20250126221225.png]]
1. 초기 마킹 STW
2. 동시 루트 탐색
3. 동시 마킹
4. 재마킹 STW (SATB기법 - STW 이후 일단 접근 가능하면 살아있는 객체로 간주)
5. 정리 STW
# 기타 GC
## 셰난도아
- 중단 시간 단축이 목표
  -> **동시 압착**
  1. 객체를 TLAB으로 추측해 복사
  2. CAS로 브룩스 포인터가 추측성사본을 가리키도록 수정, 새 위치 추적
  3. 성공 시 압착 스레드 승리, 브룩스 포인터 경유
  4. 실패 시 원상 복구
## C4(아줄 징)
- 로드값 배리어 LVB = 자가 치유 배리어
  객체 위치를 자신이 직접 가리키게 만듬
- 교대 압착
  가상 메모리 기법 활용, 다른 페이지에 복사 및 기존 페이지 반납
## 밸런스드
- 중단 시간 최소화
  **어레이릿**이라는 유사 트리 구조로 힙 배치해 GC 처리 시간 자체는 증가
- **NUMA 아키텍처**
  메모리 별 거리 존재
  가까운 노드에 있는 메모리에 객체 할당하도록 조정
## 레거시 Hotspot GC
### Serial GC
- CPU 한 코어만 사용
- Deprecated
### 증분 CMS
### 엡실론
- 실사용금지, 테스트용
