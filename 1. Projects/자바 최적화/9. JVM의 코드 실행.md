### JVM의 코드 실행기법
- 인터프리터 기법
- **JIT 컴파일 기법** -> 매우 빠름, 프로파일 기반 최적화
# 바이트코드 해석
- 스택 머신 명령어로 평가 스택 최상단의 값을 변환해 실행
#### 데이터 공간
1. 평가 스택 - 메서드 별로 생성
2. 로컬 변수
3. 객체 힙 - 메서드, 스레드 끼리 공유
### 바이트코드
- load, store, ldc - 스택 로드
- add, sub, div
- if, goto
- **invokedynamic** - 동적으로 메서드 찾기, 람다를 가능케함
- new, newarray
- etc..
- 인터프리터가 바이트 코드로 변환
- 바이트코드 사이사이가 애플리케이션 스레드를 멈추기 이상적, 세이프 포인트
<- 스레드 실행 시점엔 이미 변환된 바이트코드
# AOT와 JIT 컴파일
### AOT 컴파일
- C 방식
- 미리 컴파일 후 실행 가능한 형태로 저장
- 특정 프로세서 아키텍처 dependency
### JIT 컴파일
- 런타임에 프로그램을 최적화해 기계어로 변환
- 일반적인 JVM
- 편차가 심한 도메인 일수록 런타임 최적화가 용이함
- VM이 좋아질수록 어플리케이션 성능도 자연스레 좋아짐
# 핫스팟 JIT 기초
- 최적화된 기계어가 생성되면 해당 klass의 vtable은 새로 컴파일된 코드를 가리킴
##### klass
객체 메타데이터
##### vtable
가상 함수 테이블
### JIT 로깅
### 핫스팟 내부 컴파일러
- C1이 C2 보다 가벼움
- 메서드 호출 횟수에 따라 컴파일이 트리거링됨
- 인터프리터 < C1 < C1 풀 프로파일링(C2에서 사용) < C2
### 코드 캐시
- JIT 컴파일드 코드는 코드 캐시에 저장
- Sweeper가 청소한 블럭은 프리 리스트에 추가
### 단편화
- C1 컴파일러를 거쳤다가 C2 컴파일드된 코드가 바로 삭제되면 단편화되기 쉬움
-> C1, C2 컴파일러는 혼합되어 메모리 영역 사용하나, C2는 직전의 C1 영역이 아닌 새 영역 할당
- 압착하지 않으면 캐시 고갈
## 간단한 JIT 튜닝법
- **컴파일을 원하는 메서드에게 아낌없이 리소스를 제공하라**
- 캐시 크기를 늘리면 컴파일드 메서드 규모가 비례해 커지는가?
- 주요 트랜잭션 경로상의 주요 메서드가 모두 컴파일되는가?