# GC 로깅 개요
- GC 로깅은 시스템이 내려간 원인을 찾는데 유용
- 어플리케이션 출력과 별개로 파일에 저장해야함
## GC로그 vs JMX
- JMX는 비용 발생, GC 로그에 비해 적은 데이터
- 기본적인 힙 파악은 JMX가 간편할 수 있으나, GC로그가 GC 튜닝에 더욱 용이
### 로그 파싱 툴
- 센섬
- GC Viewer
# GC 기본 튜닝
### 먼저 고려해야할 사항
- GC가 성능저하의 근원인지 파악하는 것은 저렴
- UAT에서 GC 플래그를 키는것도 저렴
- 메모리 프로파일러, 실행 프로파일러 설정은 저렴하지 않음
### 튜닝시 주요 인자
- **할당**
- 중단 민감도
- 처리율 추이
- 객체 수명
# GC가 원인인지 파악하는법
- CPU 사용률이 100%?
- 대부분의 시간이 유저 공간에서 소비되는가?
- GC로그가 쌓이고 있으면 GC가 실행 중인 증거이다
-> 세 조건이 맞다면 GC가 원인일 가능성 높음
## 할당이란?
- 1GB/s 이상 할당률이 지속되면 GC만으로 해결못하는 성는 문제
  **-> 어플리케이션 할당 로직을 개선해야한다**
### 메모리 할당 제거 초기 전략
- 사소한 객체 할당
- 박싱 비용
- 도메인 객체
  - char[], byte[], double[], Map Entry, Object[]
    -> 덩치 큰 배열은 조기승격되어 곧바로 테뉴어드에 갈 확률이 높음
- 논 JDK 프레임워크 객체
### 조기승격에 유용한 스위치
```java
-XX:PretenureSizeThreshold=<n> // 큰 객체 조기승격 튜닝플래그
-XX:MinTLABSize=<n>

-XX:MaxTenuringThreshold=<n> // 테뉴어드 영역 승격까지의 GC 통과 제한
```
- 스위치가 어떤 영향을 반드시 벤치마킹하자
- **마이크로매니징보다는 대부분 기본 내장된 동적 기능만 사용해도 된다**
## 중단 시간이란?
- 1초 이상(Parallel..) / 1초 ~ 100밀리초(G1..) / 100밀리초 이하(CMS..)
  세 구간으로 나누어 Heap 크기와 연관지어 적합한 GC를 고려하자
## 수집기 스레드와 GC 루트
### GC 루트 탐색 시간 요인
- 어플리케이션 스레드 개수
  -> 탐색해야할 스레드 스택 갯수가 많아짐
- 코드 캐시에 쌓인 컴파일된 코드량
- 힙 크기
- 병렬화 정도
  -> 단순하게 엄청 큰 Object[]가 있다면 단일 스레드 탐색시간에 좌우
