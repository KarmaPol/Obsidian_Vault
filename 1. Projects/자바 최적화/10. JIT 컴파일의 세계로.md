# JITWatch
- JIT 최적화 알고리즘과 특성, 기법을 관찰할 수 있다
- 샌드박스를 통해 VM스위치 테스트 가능
## JIT 컴파일 개요
- 실행 프로그램 정보를 MDO에 저장 - JIT 컴파일러 언제, 어떤 최적화
- 프로파일링된 사용빈도를 기록해, 큐 맨앞에 이르렀을때 핫한 메서드만 컴파일

- C1, C2 컴파일러는 여러 기법을 조합해 최적화
- 컴파일러 종류에 따라 추측성 최적화 수행
- 추측성 최적화시 Guard라는 타당성 검사 실행
## JIT 컴파일 기법들
### 인라이닝 기법
- 피호출부를 호출부에 복사
- 가장 먼저 적용하는 기법 -> 다른 최적화의 범위 확장
#### 인라이닝 제한
- 메서드의 바이트코드 크기
- 인라이닝할 깊이
- 코드 캐시에서 차지하는 공간
-> 인라이닝 스위치로 조절 가능
### 루프 펼치기 기법
- 루프 순회 비용을 토대로 펼칠수 있음
- 루프 바디를 펼쳐 세이프 포인트 폴을 제거 가능 (스레드 멈춤 감소)
- 백 브랜치(덤프 발생률 증가) 횟수가 줄고 분기 예측 비용 감소
#### 루프 펼치기 여부 고려사항
- 루프 카운터 변수 유형 int vs long -> **int형이 루프 바디가 펼쳐져 성능이 64% 높았음**
- 루프 보폭
- 루프 내부 탈출 지점 개수
### 탈출 분석
- 내부 메서드가 실행한 결과값을 메서드 경계 밖에서도 볼수 있는지, 
side effect가 있는지 범위 기반 분석으로 판별
- **목표: 루프 등의 객체의 반복적인 힙 할당을 막고 스택에 자동 할당**
##### 탈출 분석 - 락 최적화
- 동일한 객체에 연속적으로 락이 걸려 있을 경우, 두 락 영역을 더 큰 단일 영역으로 합친다
#### 탈출 분석의 한계
- 스택은 희소한 자원! -> 스위치로 조절 가능하나 한계
### 단형성 디스패치
> "사람이 작성한 코드는 호출부의 한가지 런타임 타입이 수신자 객체 타입이 됨"
- 이후의 모든 호출이 동일한 타입일 가능성이 높음
=> 그 이후의 호출부를 대비해 캐시한다
- 이형성(두 Klass 워드를 캐시) 디스패치도 지원 
-> 다형성을 instanceof로 이형성으로 바꿔 최적화하자
### 인트린직
- JIT 동적 생성 이전에 이미 알고있는 네이티브 구현체
-> currentTimeMills(), Math..
### 온스택 치환
- 호출빈도는 높지 않지만 내부에 핫루프(반복 실행되어 성능 최적화가 필요한 루프)가 있는 경우에 최적화
-> 브랜치 횟수를 세어보고 특정 한계치 초과시 루프를 컴파일 후 치환해 최적화