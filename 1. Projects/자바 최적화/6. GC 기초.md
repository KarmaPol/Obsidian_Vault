### GC 원칙
1. 알고리즘은 반드시 모든 가비지를 수집해야한다
2. **살아있는 객체는 절대 수집하면 안된다**
## 마크 앤 스위프
- 가장 기초적인 방식
1. 할당 리스트를 순회하며 마크 삭제
2. GC 루트 부터 살아있는 객체 찾아 마크 세팅
   -> 주로 DFS 방식으로
3. 할당 리스트 순회하며 마크 세팅되지 않은 객체 삭제
### GC 용어
- STW
  GC 동안 모든 어플리케이션 스레드 중단
- 동시
  GC 스레드는 어플리케이션과 동시 실행 가능하나, 100% 동시 실행 알고리즘은 없다
- 병렬
  여러 스레드로 GC
- 정확
  정확한 GC를 위해 힙 상태에 관해 충분한 타입 정보 저장
- 보수
  정확한 스킴 X, 비효율적
- 이동
  객체 주소가 고정되지 않음
- 압착
  메모리 단편화 방지
- 방출
  수집 사이클 마지막에 살아남은 객체는 다른 메모리 영역으로 방출
## 핫스팟 런타임 개요
- 자바는 주소로 객체 역참조 불가능
- call-by-value로만 호출, 레퍼런스 타입은 힙에 있는 객체의 주소를 불러옴
### 객체를 런타임에 표시하는 방법
- 핫스팟은 **oop** 구조체로 자바 객체 표시
- 객체 oop인 instanceOop는 헤더로 시작
	- 핫스팟 객체 헤더
	  - Mark - 인스턴스 메타 데이터
	  - Klass - 클래스 메타 데이터
	  - lenght - 배열 객체일때 길이
	  - 32 비트 여백
	-> -XX:+UseCompressedOops로 압축가능하나 결국 **스위치 만지작 거리기** 안티패턴
### GC 루트 및 아레나
- GC 루트
  메모리 풀 외부에서 내부를 가리키는 포인터
- 아레나
  핫스팟 GC 작동 메모리 영역
## 할당과 수명
- 객체 수명을 제대로 파악 하기가 어려움
### 약한 세대별 가설
```
대부분의 객체는 수명이 짧지만, 나머지 객체는 매우 길다
```
- 단명 객체를 쉽고 빠르게 수집하는것이 중요
- 단명/장수 객체를 완전히 떼어놓자
- 장수할수록 
  스택 -> 에덴(**영**) -> 서바이버 -> 테뉴어드(**올드**)로 승격 (방출이라고도 함)
- G1 이후로 계속 사용 예정으로 중요
## 핫스팟의 가비지 수집
### Thread Local Allocation Buffer
- 스레드별 할당 에덴구역
- 그 다음 주소를 가리키도록 업데이트, O(1)
### 반구형 수집
- 서바이버 구역
- 객체 수집시 다른 반구로 압착해 옮기고, 완전히 비운다
  -> 테뉴어드가 단명객체로 어지러워지는 것 방지
## 병렬 수집
- parallel GC
  일반적인 영세대 병렬 수집
- parallelOld GC
  올드 세대용 병렬 수집
  하지만 살아있는 객체 수, 힙 크기에 비례해 STW 시간 증가
## 할당의 역할
- 객체 수명의 분포가 불확실하므로, 일부 객체는 테뉴어드에 도달한다
- 할당률이 높을수록, GC는 자주 발생한다
  -> 매우 높다면 테뉴어드로 곧장 승격될 것이다 => **조기 승격**
  **-> 조기 승격 증상은 GC 튜닝의 대표적인 출발점**
## 질문
- 그럼 어플리케이션을 오래 켜둘수록 올드 객체가 많아져서 느려지나?
- 조기승격이 너무 잦으면 할당률이 너무 높은거니, Heap VM 할당을 늘리면 되나?