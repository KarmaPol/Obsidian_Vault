# 상속 관계 매핑
- 일반 RDB에선 상속이 없지만 JPA는 가능함
## 상속 - 조인 전략
- 엔티티를 모두 만들고 부모 테이블의 기본키를 외래키로
- @Inheritance(InheritanceType.JOINED)
  @DiscriminatorColumn("DTYPE") - Dtype 자식 테이블 구분 컬럼 지정
  @DiscriminatorValue("M") - Dtype 자식 테이블 구분 컬럼 값 지정
- 정규화 가능
- 조인으로 인해 성능 저하, 조회 쿼리 복잡, INSERT 문 2회 실행
## 상속 - 단일 테이블 전략
- 하나의 테이블을 사용하여 조인 필요 없음
- 자식 엔티티의 매핑 컬럼은 모두 null 허용해야함
- 테이블이 지나치게 커짐
- DTYPE 컬럼이 필수적
## 상속 - 구현 클래스 마다 테이블 전략
- 여러 테이블 조회시 UNION 사용으로 느려짐
- 통합 쿼리 어려움
- **추천하지 않는 전략**
### @MappedSuperclass
- 실제 테이블과 매핑되지 않는 부모 클래스
- 컬럼 전달 용도
- 추상 클래스와 사용
# 복합키와 식별, 비식별 관계
- 식별 관계
  부모 테이블의 기본키를 받아 자식 테이블에서 기본 키 + 외래키 사용
- 비식별 관계
  부모 테이블의 기본키를 자식 테이블의 외래키로만 사용
- **최근엔 주로 비식별을 사용하는 추세**
## JPA 복합키 매핑
- 둘 이상의 식별자 클래스를 만들어야함, @Id 단순 2개 사용 X
- IdClass(데이터 지향적), EmbeddedId(객체지향적) 는 취향 차이
### @IdClass
- 복합 키 매핑용 식별자 클래스 (엔티티 아님)
- 여러개 의 @Id 매핑
- 식별 관계 표현 시 
  ```java
@Id
@ManyToOne
@JoinColumn(name = "PARENT_ID")
public Parent parent;
```
### @EmbeddedId
- 식별자 클래스에 기본키 직접 매핑
- 식별 관계 표현시 @MapsId 사용
  외래키와 매핑한 연관관계를 기본 키에도 매핑
## JPA 비식별 매핑 시
- 애초에 식별자 클래스가 필요없음
- 훨씬 간단
## 일대일 식별 관계
- 외래키인 Parent parent에 @MapsId로 지정
# 식별 관계의 장점?
- 특정 상황에 조인 없이 하위 테이블만으로 검색 가능
- 별도 인덱스 없이 기본 키 인덱스 활용 가능
- 하지만 비식별 관계 + 대리키가 주로 사용
# 조인 테이블
- 기본은 조인 컬럼(외래키)지만 필요시 사용가능
- @JoinTable로 조인 테이블 이름, 양쪽 외래키 지정
